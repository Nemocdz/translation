title: "UTF-8 字符串"
date: 
tags: [Swift,iOS]
categories: [swift.org]
permalink: utf8-string
keywords: swift,utf8,string
custom_title: "UTF-8 字符串"

------

原文链接=https://swift.org/blog/utf8-string/
作者=Michael Ilseman
原文日期=2019-03-20
译者=Nemocdz
校对=
定稿=

<!--此处开始正文-->

Swift 5 把字符串首选编码从 UTF-16 切换到 UTF-8 后，还保持着良好的 Objective-C 兼容性。这是因为 String 类型对此做了抽象，将问题隐藏在更底层了。开发者虽然无需改动任何源码*，但这个举动给现在和以后带来的收益是值得一提的。

<!--more-->

切换到 UTF-8 完成了 String 实现 [高性能处理](https://github.com/apple/swift/blob/master/docs/StringManifesto.md#high-performance-string-processing) 这个长期目标，这是性能敏感型开发者 [最关心的](https://bugs.swift.org/browse/SR-7602)。这也为以后提供更多高性能 API 奠定了基础。String 的首选编码因性能原因是需要合入 Swift ABI 的，所以需要及时进行该切换以确保 Swift 5 的 ABI 稳定性。

_* 查看下面的 “*[ 使用 `String.Index.encodedOffset` 的危害](#use-of-stringindexencodedoffset-considered-harmful)*” 来了解滥用所造成的潜在表现变化_

## 原理

### 结构的变化

尽管 String 类型从代码上看是一个结构体，但它可以以很多种形式存在。你可以把 String 想象成一个_手工制作的枚举_，手动使用传统的 [位操作（bit-twiddling）](https://en.wikipedia.org/wiki/Bit_manipulation) 技术生产而来 [紧凑](https://github.com/apple/swift/blob/19014a85af33bc29c5265a7f427c6d80fd151a1b/stdlib/public/core/StringObject.swift#L55) 且 [高效](https://github.com/apple/swift/blob/19014a85af33bc29c5265a7f427c6d80fd151a1b/stdlib/public/core/StringObject.swift#L294) 的代码。

Swift 5 之前，字符串内容可以使用两种原生存储编码之一：用于 Unicode 富文本的 UTF-16、当内容都是 ASCII 时的 ASCII 专用存储类。在 Swift 5 中，这两种编码都被一种单独的 UTF-8 存储编码取代了。

![String forms](https://swift.org/assets/images/utf8-string-blog/string-forms.png)

* _大字符串_由存储类支持，该类尾部分配内存，内容存在对象地址进行固定偏移后。
* _小字符串_的内容直接装在 String 的结构体字节里，不需要任何内存分配。
* _间接字符串_能够通过_容错函数_提供连续内容的指针和长度。（容错函数行为能在不破坏二进制兼容性的情况下被修改。）
* _不透明字符串_仅能通过容错函数实现功能，也就是说它们可以有任意的备用编码或表达形式。这意味着新的字符串形式可以在任何时间点被添加进来。作为这种灵活性的交换，它们无法享受内联和其他优化的收益。

String 支持_延迟桥接_，也就说 NSString 在导入到 Swift 时并不会被拷贝。如果一个 NSString 能够提供连续内存中的有效 UTF-8 指针（例如通过 [CFStringGetCStringPtr](https://developer.apple.com/documentation/corefoundation/1542133-cfstringgetcstringptr)），它会当作间接字符串引入。其余情况，它则当作不透明字符串引入。

更多技术细节，查看最近 Swift 论坛的文章 [揭开 String 的神秘面纱](https://forums.swift.org/t/piercing-the-string-veil/21700)。

### UTF-8：现代计算机的正确选择

原生的 UTF-8 支持对于现代计算机环境的高效兼容性是至关重要的，这些环境包括：

* 服务器和客户端编程
* 系统编程和 C 兼容性
* 开发工具（编译系统、编辑器、Linter 等）

例如，源代码（大部分内容）是用 UTF-8 编码的，所以 [SourceKit](https://github.com/apple/swift/tree/master/tools/SourceKit) 表达和传递源代码位置方式是用 UTF-8 缓冲区中的偏移量。在 Swift 4.2 中，编写一个基于 UTF-8 服务的高效客户端需要自己维护从 UTF-8 偏移量到 UTF-16 索引的双向索引映射表。Swift 4.2 里即使是由 UTF-8 内容组成的字符串，在涉及将内容转码成 UTF-16 时代价也会非常昂贵。例如，只是将 SwiftNIO 升级到 Swift 5，在给 swift.org 提供首页时便可见 20% 的速度提升，就是由于跳过了这个转码过程。

UTF-16 用于早期版本 Unicode 设计的系统，当时所有标量都可以用 16 位容纳。不幸的是，最终 16 位还是 [过于局限](https://en.wikipedia.org/wiki/Unicode#History)，现在的 Unicode 都是使用 21 位标量。Swift5 通过分摊固定时间的 UTF-16 接口来尽力提供与 Objective-C 及其他基于 UTF-16 系统的高效兼容性（查看下面的 [面包屑](#breadcrumbs) ）。但在 Swift 5 中，UTF-8 仍然是首选，且是最高效的表达方式。

## 编码之间的差异

### 内存占用

对于字符串内容里的 ASCII 部分，UTF-8 比 UTF-16 节省 50% 内存空间。对于由最近 [基本多文本平面标量](https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane) 组成的部分，UTF-8 比 UTF-16 占用多 50% 内存空间。对于大部分来源于拉丁语/希腊语或者阿拉姆语派生脚本的非 ASCII 标量，以及非 BMP 标量（例如 emoji），所有编码的占用空间是一样的。

|             |              AB |              ГД |                       いろは |                        𓀀𓂀 |
| :---------: | --------------: | --------------: | ---------------------------: | ------------------------: |
| **Scalars** | `U+0041 U+0042` | `U+0413 U+0414` |       `U+3044 U+308D U+306F` |         `U+13000 U+13080` |
|  **UTF-8**  |         `41 42` |   `D0 93 D0 94` | `E3 81 84 E3 82 8D E3 81 AF` | `F0 93 80 80 F0 93 82 80` |
| **UTF-16**  |   `41 00 42 00` |   `13 04 14 04` |          `44 30 8D 30 6F 30` | `0C D8 00 DC 0C D8 80 DC` |

_* UTF-16 是 [字节序依赖](https://en.wikipedia.org/wiki/Byte_order_mark#UTF-16) 的，这个表格列出的字节是小端字节序的。_

性能敏感型字符串处理通常涉及解决重量级 ASCII 文本问题，这是 UTF-8 优势所在。

